"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const eslint_utils_1 = require("eslint-utils");
const svelte_compile_warns_1 = require("../shared/svelte-compile-warns");
const utils_1 = require("../utils");
const SVELTE_IGNORE_PATTERN = /^\s*svelte-ignore/m;
function hasMissingCodeIgnore(text) {
    const m1 = SVELTE_IGNORE_PATTERN.exec(text);
    if (!m1) {
        return false;
    }
    const ignoreStart = m1.index + m1[0].length;
    const beforeText = text.slice(ignoreStart);
    return !beforeText.trim();
}
function extractSvelteIgnore(text, startIndex, token) {
    const m1 = SVELTE_IGNORE_PATTERN.exec(text);
    if (!m1) {
        return null;
    }
    const ignoreStart = m1.index + m1[0].length;
    const beforeText = text.slice(ignoreStart);
    if (!/^\s/.test(beforeText) || !beforeText.trim()) {
        return null;
    }
    let start = startIndex + ignoreStart;
    const results = [];
    for (const code of beforeText.split(/\s/)) {
        const end = start + code.length;
        const trimmed = code.trim();
        if (trimmed) {
            results.push({
                code: trimmed,
                range: [start, end],
                token,
            });
        }
        start = end + 1;
    }
    return results;
}
exports.default = (0, utils_1.createRule)("no-unused-svelte-ignore", {
    meta: {
        docs: {
            description: "disallow unused svelte-ignore comments",
            category: "Best Practices",
            recommended: true,
        },
        schema: [],
        messages: {
            unused: "svelte-ignore comment is used, but not warned",
            missingCode: "svelte-ignore comment must include the code",
        },
        type: "suggestion",
    },
    create(context) {
        const sourceCode = context.getSourceCode();
        const ignoreComments = [];
        const used = new Set();
        for (const comment of sourceCode.getAllComments()) {
            const ignores = extractSvelteIgnore(comment.value, comment.range[0] + 2, comment);
            if (ignores) {
                ignoreComments.push(...ignores);
            }
            else if (hasMissingCodeIgnore(comment.value)) {
                context.report({
                    node: comment,
                    messageId: "missingCode",
                });
            }
        }
        for (const token of sourceCode.ast.tokens) {
            if (token.type === "HTMLComment") {
                const text = token.value.slice(4, -3);
                const ignores = extractSvelteIgnore(text, token.range[0] + 4, token);
                if (ignores) {
                    ignoreComments.push(...ignores);
                }
                else if (hasMissingCodeIgnore(text)) {
                    context.report({
                        node: token,
                        messageId: "missingCode",
                    });
                }
            }
        }
        ignoreComments.sort((a, b) => b.range[0] - a.range[0]);
        if (!ignoreComments.length) {
            return {};
        }
        const warnings = (0, svelte_compile_warns_1.getSvelteCompileWarnings)(context, {
            warnings: "onlyWarnings",
            removeComments: new Set(ignoreComments.map((i) => i.token)),
        });
        if (!warnings) {
            return {};
        }
        for (const warning of warnings) {
            if (!warning.code) {
                continue;
            }
            const node = getWarningNode(warning);
            if (!node) {
                continue;
            }
            l: for (const comment of extractLeadingComments(node).reverse()) {
                for (const ignoreItem of ignoreComments) {
                    if (ignoreItem.token === comment &&
                        ignoreItem.code === warning.code) {
                        used.add(ignoreItem);
                        break l;
                    }
                }
            }
        }
        for (const unused of ignoreComments.filter((i) => !used.has(i))) {
            context.report({
                loc: {
                    start: sourceCode.getLocFromIndex(unused.range[0]),
                    end: sourceCode.getLocFromIndex(unused.range[1]),
                },
                messageId: "unused",
            });
        }
        return {};
        function getWarningNode(warning) {
            const index = getWarningIndex(warning);
            if (index == null) {
                return null;
            }
            let targetNode = sourceCode.getNodeByRangeIndex(index);
            while (targetNode) {
                if (targetNode.type === "SvelteElement") {
                    return targetNode;
                }
                if (targetNode.parent) {
                    if (targetNode.parent.type === "Program" ||
                        targetNode.parent.type === "SvelteScriptElement") {
                        return targetNode;
                    }
                }
                else {
                    return null;
                }
                targetNode = targetNode.parent || null;
            }
            return null;
        }
        function getWarningIndex(warning) {
            const start = warning.start && sourceCode.getIndexFromLoc(warning.start);
            const end = warning.end && sourceCode.getIndexFromLoc(warning.end);
            if (start != null && end != null) {
                return Math.floor(start + (end - start) / 2);
            }
            return start !== null && start !== void 0 ? start : end;
        }
        function extractLeadingComments(node) {
            const beforeToken = sourceCode.getTokenBefore(node, {
                includeComments: false,
                filter(token) {
                    if ((0, eslint_utils_1.isOpeningParenToken)(token)) {
                        return false;
                    }
                    const astToken = token;
                    if (astToken.type === "HTMLText") {
                        return Boolean(astToken.value.trim());
                    }
                    return astToken.type !== "HTMLComment";
                },
            });
            if (beforeToken) {
                return sourceCode
                    .getTokensBetween(beforeToken, node, { includeComments: true })
                    .filter(isComment);
            }
            return sourceCode
                .getTokensBefore(node, { includeComments: true })
                .filter(isComment);
        }
    },
});
function isComment(token) {
    return (token.type === "HTMLComment" ||
        token.type === "Block" ||
        token.type === "Line");
}
