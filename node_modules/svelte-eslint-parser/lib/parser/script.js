"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseScript = void 0;
const analyze_scope_1 = require("./analyze-scope");
const traverse_1 = require("../traverse");
const resolve_parser_1 = require("./resolve-parser");
/**
 * Parse for script
 */
function parseScript(script, parserOptions = {}) {
    const result = parseScriptWithoutAnalyzeScope(script, parserOptions);
    if (!result.scopeManager) {
        const scopeManager = (0, analyze_scope_1.analyzeScope)(result.ast, parserOptions);
        result.scopeManager = scopeManager;
    }
    (0, traverse_1.traverseNodes)(result.ast, {
        visitorKeys: result.visitorKeys,
        enterNode(node, parent) {
            ;
            node.parent = parent;
            if (node.type === "LabeledStatement" && node.label.name === "$") {
                if ((parent === null || parent === void 0 ? void 0 : parent.type) === "Program") {
                    // Transform node type
                    node.type = "SvelteReactiveStatement";
                }
            }
        },
        leaveNode() {
            //
        },
    });
    return result;
}
exports.parseScript = parseScript;
/**
 * Parse for script without analyze scope
 */
function parseScriptWithoutAnalyzeScope({ vcode, attrs }, options) {
    var _a, _b, _c;
    const parser = (0, resolve_parser_1.getParser)(attrs, options.parser);
    const result = (_b = (_a = parser.parseForESLint) === null || _a === void 0 ? void 0 : _a.call(parser, vcode, options)) !== null && _b !== void 0 ? _b : (_c = parser.parse) === null || _c === void 0 ? void 0 : _c.call(parser, vcode, options);
    if ("ast" in result && result.ast != null) {
        return result;
    }
    return { ast: result };
}
