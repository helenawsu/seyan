import type { ScopeManager, Scope } from "eslint-scope";
import type * as ESTree from "estree";
import type { Context } from ".";
import type { Comment, SvelteEachBlock, SvelteIfBlock, SvelteName, SvelteNode, Token } from "../ast";
import type { ESLintExtendedProgram } from "../parser";
export declare type ScriptLetCallback<E extends ESTree.Node> = (es: E, options: ScriptLetCallbackOption) => void;
export declare type ScriptLetCallbackOption = {
    getScope: (node: ESTree.Node) => Scope;
    getInnermostScope: (node: ESTree.Node) => Scope;
    registerNodeToScope: (node: any, scope: Scope) => void;
    scopeManager: ScopeManager;
    visitorKeys?: {
        [type: string]: string[];
    };
};
export declare type ScriptLetRestoreCallback = (node: ESTree.Node, tokens: Token[], comments: Comment[], options: ScriptLetRestoreCallbackOption) => void;
declare type ScriptLetRestoreCallbackOption = {
    getScope: (node: ESTree.Node) => Scope;
    getInnermostScope: (node: ESTree.Node) => Scope;
    registerNodeToScope: (node: any, scope: Scope) => void;
    scopeManager: ScopeManager;
    visitorKeys?: {
        [type: string]: string[];
    };
};
declare type TypeGenHelper = {
    generateUniqueId: (base: string) => string;
};
/**
 * A class that handles script fragments.
 * The script fragment AST node remaps and connects to the original directive AST node.
 */
export declare class ScriptLetContext {
    private readonly script;
    private readonly ctx;
    private readonly restoreCallbacks;
    private readonly closeScopeCallbacks;
    private uniqueIdSeq;
    private readonly usedUniqueIds;
    constructor(ctx: Context);
    addExpression<E extends ESTree.Expression>(expression: E | SvelteName, parent: SvelteNode, typing?: string | null, ...callbacks: ScriptLetCallback<E>[]): ScriptLetCallback<E>[];
    addVariableDeclarator(expression: ESTree.AssignmentExpression, parent: SvelteNode, ...callbacks: ScriptLetCallback<ESTree.VariableDeclarator>[]): ScriptLetCallback<ESTree.VariableDeclarator>[];
    nestIfBlock(expression: ESTree.Expression, ifBlock: SvelteIfBlock, callback: ScriptLetCallback<ESTree.Expression>): void;
    nestEachBlock(expression: ESTree.Expression, context: ESTree.Pattern, indexRange: {
        start: number;
        end: number;
    } | null, eachBlock: SvelteEachBlock, callback: (expr: ESTree.Expression, ctx: ESTree.Pattern, index: ESTree.Identifier | null) => void): void;
    nestBlock(block: SvelteNode): void;
    nestBlock(block: SvelteNode, params: (ESTree.Pattern | SvelteName)[], parents: SvelteNode[], callback: (nodes: ESTree.Pattern[], options: ScriptLetCallbackOption) => void, typings: string[] | ((helper: TypeGenHelper) => {
        typings: string[];
        preparationScript?: string[];
    })): void;
    closeScope(): void;
    private appendScript;
    private appendScriptWithoutOffset;
    private pushScope;
    /**
     * Restore AST nodes
     */
    restore(result: ESLintExtendedProgram): void;
    private remapNodes;
    /** Fix locations */
    private fixLocations;
    private generateUniqueId;
}
export {};
