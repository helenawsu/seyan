"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScriptLetContext = void 0;
const common_1 = require("../parser/converts/common");
const traverse_1 = require("../traverse");
/**
 * Get node range
 */
function getNodeRange(node) {
    let start = null;
    let end = null;
    if (node.leadingComments) {
        start = (0, common_1.getWithLoc)(node.leadingComments[0]).start;
    }
    if (node.trailingComments) {
        end = (0, common_1.getWithLoc)(node.trailingComments[node.trailingComments.length - 1]).end;
    }
    if (start != null && end != null) {
        return [start, end];
    }
    if ("range" in node) {
        return [start !== null && start !== void 0 ? start : node.range[0], end !== null && end !== void 0 ? end : node.range[1]];
    }
    const loc = (0, common_1.getWithLoc)(node);
    return [start !== null && start !== void 0 ? start : loc.start, end !== null && end !== void 0 ? end : loc.end];
}
/**
 * A class that handles script fragments.
 * The script fragment AST node remaps and connects to the original directive AST node.
 */
class ScriptLetContext {
    constructor(ctx) {
        this.restoreCallbacks = [];
        this.closeScopeCallbacks = [];
        this.uniqueIdSeq = 1;
        this.usedUniqueIds = new Set();
        this.script = ctx.sourceCode.scripts;
        this.ctx = ctx;
    }
    addExpression(expression, parent, typing, ...callbacks) {
        const range = getNodeRange(expression);
        const part = this.ctx.code.slice(...range);
        const isTS = typing && this.ctx.isTypeScript();
        this.appendScript(`(${part})${isTS ? `as (${typing})` : ""};`, range[0] - 1, (st, tokens, comments, result) => {
            const exprSt = st;
            const tsAs = isTS
                ? exprSt.expression
                : null;
            const node = (tsAs === null || tsAs === void 0 ? void 0 : tsAs.expression) || exprSt.expression;
            // Process for nodes
            for (const callback of callbacks) {
                callback(node, result);
            }
            ;
            node.parent = parent;
            tokens.shift(); // (
            tokens.pop(); // )
            tokens.pop(); // ;
            if (isTS) {
                removeScope(result.scopeManager, result.getScope(tsAs.typeAnnotation.type === "TSParenthesizedType"
                    ? tsAs.typeAnnotation.typeAnnotation
                    : tsAs.typeAnnotation));
                this.remapNodes([
                    {
                        offset: range[0] - 1,
                        range,
                        newNode: node,
                    },
                ], tokens, comments, result.visitorKeys);
            }
            // Disconnect the tree structure.
            exprSt.expression = null;
        });
        return callbacks;
    }
    addVariableDeclarator(expression, parent, ...callbacks) {
        const range = getNodeRange(expression);
        const part = this.ctx.code.slice(...range);
        this.appendScript(`const ${part};`, range[0] - 6, (st, tokens, _comments, result) => {
            const decl = st;
            const node = decl.declarations[0];
            // Process for nodes
            for (const callback of callbacks) {
                callback(node, result);
            }
            ;
            node.parent = parent;
            const scope = result.getScope(decl);
            for (const variable of scope.variables) {
                for (const def of variable.defs) {
                    if (def.parent === decl) {
                        ;
                        def.parent = parent;
                    }
                }
            }
            tokens.shift(); // const
            tokens.pop(); // ;
            // Disconnect the tree structure.
            decl.declarations = [];
        });
        return callbacks;
    }
    nestIfBlock(expression, ifBlock, callback) {
        const range = getNodeRange(expression);
        const part = this.ctx.code.slice(...range);
        const restore = this.appendScript(`if(${part}){`, range[0] - 3, (st, tokens, _comments, result) => {
            const ifSt = st;
            const node = ifSt.test;
            const scope = result.getScope(ifSt.consequent);
            // Process for nodes
            callback(node, result);
            node.parent = ifBlock;
            // Process for scope
            result.registerNodeToScope(ifBlock, scope);
            tokens.shift(); // if
            tokens.shift(); // (
            tokens.pop(); // )
            tokens.pop(); // {
            tokens.pop(); // }
            // Disconnect the tree structure.
            ifSt.test = null;
            ifSt.consequent = null;
        });
        this.pushScope(restore, "}");
    }
    nestEachBlock(expression, context, indexRange, eachBlock, callback) {
        const exprRange = getNodeRange(expression);
        const ctxRange = getNodeRange(context);
        let source = "Array.from(";
        const exprOffset = source.length;
        source += `${this.ctx.code.slice(...exprRange)}).forEach((`;
        const ctxOffset = source.length;
        source += this.ctx.code.slice(...ctxRange);
        let idxOffset = null;
        if (indexRange) {
            source += ",";
            idxOffset = source.length;
            source += this.ctx.code.slice(indexRange.start, indexRange.end);
        }
        source += ")=>{";
        const restore = this.appendScript(source, exprRange[0] - exprOffset, (st, tokens, comments, result) => {
            var _a;
            const expSt = st;
            const call = expSt.expression;
            const fn = call.arguments[0];
            const callArrayFrom = call.callee
                .object;
            const expr = callArrayFrom.arguments[0];
            const ctx = fn.params[0];
            const idx = ((_a = fn.params[1]) !== null && _a !== void 0 ? _a : null);
            const scope = result.getScope(fn.body);
            // Process for nodes
            callback(expr, ctx, idx);
            expr.parent = eachBlock;
            ctx.parent = eachBlock;
            if (idx) {
                ;
                idx.parent = eachBlock;
            }
            // Process for scope
            result.registerNodeToScope(eachBlock, scope);
            for (const v of scope.variables) {
                for (const def of v.defs) {
                    if (def.node === fn) {
                        def.node = eachBlock;
                    }
                }
            }
            // remove Array reference
            const arrayId = callArrayFrom.callee.object;
            const ref = scope.upper.references.find((r) => r.identifier === arrayId);
            if (ref) {
                removeReference(ref, scope.upper);
            }
            tokens.shift(); // Array
            tokens.shift(); // .
            tokens.shift(); // from
            tokens.shift(); // (
            tokens.pop(); // )
            tokens.pop(); // =>
            tokens.pop(); // {
            tokens.pop(); // }
            tokens.pop(); // )
            tokens.pop(); // ;
            const map = [
                {
                    offset: exprOffset,
                    range: exprRange,
                    newNode: expr,
                },
                {
                    offset: ctxOffset,
                    range: ctxRange,
                    newNode: ctx,
                },
            ];
            if (indexRange) {
                map.push({
                    offset: idxOffset,
                    range: [indexRange.start, indexRange.end],
                    newNode: idx,
                });
            }
            this.remapNodes(map, tokens, comments, result.visitorKeys);
            // Disconnect the tree structure.
            expSt.expression = null;
        });
        this.pushScope(restore, "});");
    }
    nestBlock(block, params, parents, callback, typings) {
        let arrayTypings = [];
        if (typings && this.ctx.isTypeScript()) {
            if (Array.isArray(typings)) {
                arrayTypings = typings;
            }
            else {
                const generatedTypes = typings({
                    generateUniqueId: (base) => this.generateUniqueId(base),
                });
                arrayTypings = generatedTypes.typings;
                if (generatedTypes.preparationScript) {
                    for (const preparationScript of generatedTypes.preparationScript) {
                        this.appendScriptWithoutOffset(preparationScript, (node, tokens, comments, result) => {
                            tokens.length = 0;
                            comments.length = 0;
                            removeAllScope(node, result);
                        });
                    }
                }
            }
        }
        if (!params) {
            const restore = this.appendScript(`{`, block.range[0], (st, tokens, _comments, result) => {
                const blockSt = st;
                // Process for scope
                const scope = result.getScope(blockSt);
                result.registerNodeToScope(block, scope);
                tokens.length = 0; // clear tokens
                // Disconnect the tree structure.
                blockSt.body = null;
            });
            this.pushScope(restore, "}");
        }
        else {
            const ranges = params.map(getNodeRange).sort(([a], [b]) => a - b);
            const maps = [];
            let source = "";
            for (let index = 0; index < ranges.length; index++) {
                const range = ranges[index];
                if (source) {
                    source += ",";
                }
                const offset = source.length + 1; /* ( */
                source += this.ctx.code.slice(...range);
                maps.push({
                    index: maps.length,
                    offset,
                    range,
                });
                if (this.ctx.isTypeScript()) {
                    source += ` : (${arrayTypings[index]})`;
                }
            }
            const restore = this.appendScript(`(${source})=>{`, maps[0].range[0] - 1, (st, tokens, comments, result) => {
                const exprSt = st;
                const fn = exprSt.expression;
                const scope = result.getScope(fn.body);
                // Process for nodes
                callback(fn.params, result);
                for (let index = 0; index < fn.params.length; index++) {
                    const p = fn.params[index];
                    p.parent = parents[index];
                    if (this.ctx.isTypeScript()) {
                        const typeAnnotation = p.typeAnnotation;
                        delete p.typeAnnotation;
                        p.range[1] = typeAnnotation.range[0];
                        p.loc.end = {
                            line: typeAnnotation.loc.start.line,
                            column: typeAnnotation.loc.start.column,
                        };
                        removeAllScope(typeAnnotation, result);
                    }
                }
                // Process for scope
                result.registerNodeToScope(block, scope);
                for (const v of scope.variables) {
                    for (const def of v.defs) {
                        if (def.node === fn) {
                            def.node = block;
                        }
                    }
                }
                tokens.shift(); // (
                tokens.pop(); // )
                tokens.pop(); // =>
                tokens.pop(); // {
                tokens.pop(); // }
                tokens.pop(); // ;
                this.remapNodes(maps.map((m) => {
                    return {
                        offset: m.offset,
                        range: m.range,
                        newNode: fn.params[m.index],
                    };
                }), tokens, comments, result.visitorKeys);
                // Disconnect the tree structure.
                exprSt.expression = null;
            });
            this.pushScope(restore, "};");
        }
    }
    closeScope() {
        this.closeScopeCallbacks.pop()();
    }
    appendScript(text, offset, callback) {
        const resultCallback = this.appendScriptWithoutOffset(text, (node, tokens, comments, result) => {
            this.fixLocations(node, tokens, comments, offset - resultCallback.start, result.visitorKeys);
            callback(node, tokens, comments, result);
        });
        return resultCallback;
    }
    appendScriptWithoutOffset(text, callback) {
        const { start: startOffset, end: endOffset } = this.script.addLet(text);
        const restoreCallback = {
            start: startOffset,
            end: endOffset,
            callback,
        };
        this.restoreCallbacks.push(restoreCallback);
        return restoreCallback;
    }
    pushScope(restoreCallback, closeToken) {
        this.closeScopeCallbacks.push(() => {
            this.script.addLet(closeToken);
            restoreCallback.end = this.script.vcode.length;
        });
    }
    /**
     * Restore AST nodes
     */
    restore(result) {
        let orderedRestoreCallback = this.restoreCallbacks.shift();
        if (!orderedRestoreCallback) {
            return;
        }
        const separateIndexes = this.script.separateIndexes;
        const tokens = result.ast.tokens;
        const processedTokens = [];
        const comments = result.ast.comments;
        const processedComments = [];
        const nodeToScope = getNodeToScope(result.scopeManager);
        let tok;
        while ((tok = tokens.shift())) {
            if (separateIndexes.includes(tok.range[0]) && tok.value === ";") {
                break;
            }
            if (orderedRestoreCallback.start <= tok.range[0]) {
                tokens.unshift(tok);
                break;
            }
            processedTokens.push(tok);
        }
        while ((tok = comments.shift())) {
            if (orderedRestoreCallback.start <= tok.range[0]) {
                comments.unshift(tok);
                break;
            }
            processedComments.push(tok);
        }
        const targetNodes = new Map();
        const removeStatements = [];
        (0, traverse_1.traverseNodes)(result.ast, {
            visitorKeys: result.visitorKeys,
            enterNode: (node) => {
                while (node.range &&
                    separateIndexes.includes(node.range[1] - 1)) {
                    node.range[1]--;
                    node.loc.end.column--;
                }
                if (node.loc.end.column < 0) {
                    node.loc.end = this.ctx.getLocFromIndex(node.range[1]);
                }
                if (node.parent === result.ast &&
                    separateIndexes[0] <= node.range[0]) {
                    removeStatements.push(node);
                }
                if (!orderedRestoreCallback) {
                    return;
                }
                if (orderedRestoreCallback.start <= node.range[0] &&
                    node.range[1] <= orderedRestoreCallback.end) {
                    targetNodes.set(node, orderedRestoreCallback);
                    orderedRestoreCallback = this.restoreCallbacks.shift();
                }
                //
            },
            leaveNode(node) {
                const restoreCallback = targetNodes.get(node);
                if (!restoreCallback) {
                    return;
                }
                const startIndex = {
                    token: tokens.findIndex((t) => restoreCallback.start <= t.range[0]),
                    comment: comments.findIndex((t) => restoreCallback.start <= t.range[0]),
                };
                const endIndex = {
                    token: tokens.findIndex((t) => restoreCallback.end < t.range[1], startIndex.token),
                    comment: comments.findIndex((t) => restoreCallback.end < t.range[1], startIndex.comment),
                };
                if (endIndex.token === -1) {
                    endIndex.token = tokens.length;
                }
                if (endIndex.comment === -1) {
                    endIndex.comment = comments.length;
                }
                const targetTokens = tokens.splice(startIndex.token, endIndex.token - startIndex.token);
                const targetComments = comments.splice(startIndex.comment, endIndex.comment - startIndex.comment);
                restoreCallback.callback(node, targetTokens, targetComments, {
                    getScope: getScopeFromNode,
                    getInnermostScope: getInnermostScopeFromNode,
                    registerNodeToScope,
                    scopeManager: result.scopeManager,
                    visitorKeys: result.visitorKeys,
                });
                processedTokens.push(...targetTokens);
                processedComments.push(...targetComments);
            },
        });
        for (const st of removeStatements) {
            const index = result.ast.body.indexOf(st);
            result.ast.body.splice(index, 1);
        }
        result.ast.tokens = processedTokens;
        result.ast.comments = processedComments;
        // Helpers
        /** Get scope */
        function getScopeFromNode(node) {
            return getScope(result.scopeManager, node);
        }
        /** Get innermost scope */
        function getInnermostScopeFromNode(node) {
            return getInnermostScope(getScopeFromNode(node), node);
        }
        /** Register node to scope */
        function registerNodeToScope(node, scope) {
            scope.block = node;
            const scopes = nodeToScope.get(node);
            if (scopes) {
                scopes.push(scope);
            }
            else {
                nodeToScope.set(node, [scope]);
            }
        }
    }
    remapNodes(maps, tokens, comments, visitorKeys) {
        const targetMaps = [...maps];
        const first = targetMaps.shift();
        let tokenIndex = 0;
        for (; tokenIndex < tokens.length; tokenIndex++) {
            const token = tokens[tokenIndex];
            if (first.range[1] <= token.range[0]) {
                break;
            }
        }
        for (const map of targetMaps) {
            const startOffset = map.offset - first.offset + first.range[0];
            const endOffset = startOffset + (map.range[1] - map.range[0]);
            let removeCount = 0;
            let target = tokens[tokenIndex];
            while (target && target.range[1] <= startOffset) {
                removeCount++;
                target = tokens[tokenIndex + removeCount];
            }
            if (removeCount) {
                tokens.splice(tokenIndex, removeCount);
            }
            const bufferTokens = [];
            for (; tokenIndex < tokens.length; tokenIndex++) {
                const token = tokens[tokenIndex];
                if (endOffset <= token.range[0]) {
                    break;
                }
                bufferTokens.push(token);
            }
            this.fixLocations(map.newNode, bufferTokens, comments.filter((t) => startOffset <= t.range[0] && t.range[1] <= endOffset), map.range[0] - startOffset, visitorKeys);
        }
        tokens.splice(tokenIndex);
    }
    /** Fix locations */
    fixLocations(node, tokens, comments, offset, visitorKeys) {
        if (offset === 0) {
            return;
        }
        const traversed = new Set();
        (0, traverse_1.traverseNodes)(node, {
            visitorKeys,
            enterNode: (n) => {
                if (traversed.has(n)) {
                    return;
                }
                traversed.add(n);
                if (traversed.has(n.range)) {
                    if (!traversed.has(n.loc)) {
                        // However, `Node#loc` may not be shared.
                        const locs = this.ctx.getConvertLocation({
                            start: n.range[0],
                            end: n.range[1],
                        });
                        applyLocs(n, locs);
                        traversed.add(n.loc);
                    }
                }
                else {
                    const start = n.range[0] + offset;
                    const end = n.range[1] + offset;
                    const locs = this.ctx.getConvertLocation({ start, end });
                    applyLocs(n, locs);
                    traversed.add(n.range);
                    traversed.add(n.loc);
                }
            },
            leaveNode: Function.prototype,
        });
        for (const t of tokens) {
            const start = t.range[0] + offset;
            const end = t.range[1] + offset;
            const locs = this.ctx.getConvertLocation({ start, end });
            applyLocs(t, locs);
        }
        for (const t of comments) {
            const start = t.range[0] + offset;
            const end = t.range[1] + offset;
            const locs = this.ctx.getConvertLocation({ start, end });
            applyLocs(t, locs);
        }
    }
    generateUniqueId(base) {
        let candidate = `$_${base.replace(/\W/g, "_")}${this.uniqueIdSeq++}`;
        while (this.usedUniqueIds.has(candidate) ||
            this.ctx.code.includes(candidate) ||
            this.script.vcode.includes(candidate)) {
            candidate = `$_${base.replace(/\W/g, "_")}${this.uniqueIdSeq++}`;
        }
        this.usedUniqueIds.add(candidate);
        return candidate;
    }
}
exports.ScriptLetContext = ScriptLetContext;
/**
 * Gets the scope for the current node
 */
function getScope(scopeManager, currentNode) {
    let node = currentNode;
    for (; node; node = node.parent || null) {
        const scope = scopeManager.acquire(node, false);
        if (scope) {
            if (scope.type === "function-expression-name") {
                return scope.childScopes[0];
            }
            return scope;
        }
    }
    const global = scopeManager.globalScope;
    return global;
}
/**
 * Get the innermost scope which contains a given location.
 * @param initialScope The initial scope to search.
 * @param node The location to search.
 * @returns The innermost scope.
 */
function getInnermostScope(initialScope, node) {
    const location = node.range[0];
    for (const childScope of initialScope.childScopes) {
        const range = childScope.block.range;
        if (range[0] <= location && location < range[1]) {
            return getInnermostScope(childScope, node);
        }
    }
    return initialScope;
}
/**
 * applyLocs
 */
function applyLocs(target, locs) {
    target.loc = locs.loc;
    target.range = locs.range;
    if (typeof target.start === "number") {
        delete target.start;
    }
    if (typeof target.end === "number") {
        delete target.end;
    }
}
/** Remove all reference */
function removeAllScope(target, result) {
    const targetScopes = new Set();
    (0, traverse_1.traverseNodes)(target, {
        visitorKeys: result.visitorKeys,
        enterNode(node) {
            const scope = result.scopeManager.acquire(node);
            if (scope) {
                targetScopes.add(scope);
                return;
            }
            if (node.type === "Identifier") {
                let scope = result.getScope(node);
                if (scope.block.type === "TSTypeAliasDeclaration" &&
                    scope.block.id === node) {
                    scope = scope.upper;
                }
                if (targetScopes.has(scope)) {
                    return;
                }
                removeIdentifierVariable(node, scope);
                removeIdentifierReference(node, scope);
            }
        },
        leaveNode() {
            // noop
        },
    });
    for (const scope of targetScopes) {
        removeScope(result.scopeManager, scope);
    }
}
/** Remove variable */
function removeIdentifierVariable(node, scope) {
    const varIndex = scope.variables.findIndex((v) => v.defs.some((def) => def.name === node));
    if (varIndex >= 0) {
        const variable = scope.variables[varIndex];
        scope.variables.splice(varIndex, 1);
        const name = node.name;
        if (variable === scope.set.get(name)) {
            scope.set.delete(name);
        }
    }
}
/** Remove reference */
function removeIdentifierReference(node, scope) {
    const reference = scope.references.find((ref) => ref.identifier === node);
    if (reference) {
        removeReference(reference, scope);
        return true;
    }
    const location = node.range[0];
    const pendingScopes = [];
    for (const childScope of scope.childScopes) {
        const range = childScope.block.range;
        if (range[0] <= location && location < range[1]) {
            if (removeIdentifierReference(node, childScope)) {
                return true;
            }
        }
        else {
            pendingScopes.push(childScope);
        }
    }
    for (const childScope of pendingScopes) {
        if (removeIdentifierReference(node, childScope)) {
            return true;
        }
    }
    return false;
}
/** Remove reference */
function removeReference(reference, baseScope) {
    if (reference.resolved) {
        if (reference.resolved.defs.some((d) => d.name === reference.identifier)) {
            // remove var
            const varIndex = baseScope.variables.indexOf(reference.resolved);
            if (varIndex >= 0) {
                baseScope.variables.splice(varIndex, 1);
            }
            const name = reference.identifier.name;
            if (reference.resolved === baseScope.set.get(name)) {
                baseScope.set.delete(name);
            }
        }
        else {
            const refIndex = reference.resolved.references.indexOf(reference);
            if (refIndex >= 0) {
                reference.resolved.references.splice(refIndex, 1);
            }
        }
    }
    let scope = baseScope;
    while (scope) {
        const refIndex = scope.references.indexOf(reference);
        if (refIndex >= 0) {
            scope.references.splice(refIndex, 1);
        }
        const throughIndex = scope.through.indexOf(reference);
        if (throughIndex >= 0) {
            scope.through.splice(throughIndex, 1);
        }
        scope = scope.upper;
    }
}
/** Remove scope */
function removeScope(scopeManager, scope) {
    for (const childScope of scope.childScopes) {
        removeScope(scopeManager, childScope);
    }
    while (scope.references[0]) {
        removeReference(scope.references[0], scope);
    }
    const upper = scope.upper;
    if (upper) {
        const index = upper.childScopes.indexOf(scope);
        if (index >= 0) {
            upper.childScopes.splice(index, 1);
        }
    }
    const index = scopeManager.scopes.indexOf(scope);
    if (index >= 0) {
        scopeManager.scopes.splice(index, 1);
    }
}
/** Get the node to scope map from given scope manager  */
function getNodeToScope(scopeManager) {
    if ("__nodeToScope" in scopeManager) {
        return scopeManager.__nodeToScope;
    }
    // transform scopeManager
    const nodeToScope = new WeakMap();
    for (const scope of scopeManager.scopes) {
        const scopes = nodeToScope.get(scope.block);
        if (scopes) {
            scopes.push(scope);
        }
        else {
            nodeToScope.set(scope.block, [scope]);
        }
    }
    scopeManager.acquire = function (node, inner) {
        /**
         * predicate
         */
        function predicate(testScope) {
            if (testScope.type === "function" &&
                testScope.functionExpressionScope) {
                return false;
            }
            return true;
        }
        const scopes = nodeToScope.get(node);
        if (!scopes || scopes.length === 0) {
            return null;
        }
        // Heuristic selection from all scopes.
        // If you would like to get all scopes, please use ScopeManager#acquireAll.
        if (scopes.length === 1) {
            return scopes[0];
        }
        if (inner) {
            for (let i = scopes.length - 1; i >= 0; --i) {
                const scope = scopes[i];
                if (predicate(scope)) {
                    return scope;
                }
            }
        }
        else {
            for (let i = 0, iz = scopes.length; i < iz; ++i) {
                const scope = scopes[i];
                if (predicate(scope)) {
                    return scope;
                }
            }
        }
        return null;
    };
    return nodeToScope;
}
