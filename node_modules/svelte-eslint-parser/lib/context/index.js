"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinesAndColumns = exports.Context = exports.ScriptsSourceCode = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const script_let_1 = require("./script-let");
const let_directive_collection_1 = require("./let-directive-collection");
const resolve_parser_1 = require("../parser/resolve-parser");
const html_1 = require("../parser/html");
class ScriptsSourceCode {
    constructor(script, attrs) {
        this._appendScriptLets = null;
        this.separateIndexes = [];
        this.raw = script;
        this.trimmedRaw = script.trimEnd();
        this.attrs = attrs;
        this.separateIndexes = [script.length];
    }
    get vcode() {
        if (this._appendScriptLets == null) {
            return this.raw;
        }
        return this.trimmedRaw + this._appendScriptLets;
    }
    addLet(letCode) {
        if (this._appendScriptLets == null) {
            this._appendScriptLets = "";
            this.separateIndexes = [this.vcode.length, this.vcode.length + 1];
            this._appendScriptLets += "\n;";
            const after = this.raw.slice(this.vcode.length);
            this._appendScriptLets += after;
        }
        const start = this.vcode.length;
        this._appendScriptLets += letCode;
        return {
            start,
            end: this.vcode.length,
        };
    }
    stripCode(start, end) {
        this.raw =
            this.raw.slice(0, start) +
                this.raw.slice(start, end).replace(/[^\n\r ]/g, " ") +
                this.raw.slice(end);
        this.trimmedRaw =
            this.trimmedRaw.slice(0, start) +
                this.trimmedRaw.slice(start, end).replace(/[^\n\r ]/g, " ") +
                this.trimmedRaw.slice(end);
    }
}
exports.ScriptsSourceCode = ScriptsSourceCode;
class Context {
    constructor(code, parserOptions) {
        var _a;
        this.tokens = [];
        this.comments = [];
        this.locsMap = new Map();
        this.letDirCollections = new let_directive_collection_1.LetDirectiveCollections();
        this.state = {};
        this.blocks = [];
        this.code = code;
        this.parserOptions = parserOptions;
        this.locs = new LinesAndColumns(code);
        const spaces = code.replace(/[^\n\r ]/g, " ");
        let templateCode = "";
        let scriptCode = "";
        const scriptAttrs = {};
        let start = 0;
        for (const block of extractBlocks(code)) {
            this.blocks.push(block);
            templateCode +=
                code.slice(start, block.contentRange[0]) +
                    spaces.slice(block.contentRange[0], block.contentRange[1]);
            if (block.tag === "script") {
                scriptCode +=
                    spaces.slice(start, block.contentRange[0]) +
                        code.slice(...block.contentRange);
                for (const attr of block.attrs) {
                    scriptAttrs[attr.key.name] = (_a = attr.value) === null || _a === void 0 ? void 0 : _a.value;
                }
            }
            else {
                scriptCode += spaces.slice(start, block.contentRange[1]);
            }
            start = block.contentRange[1];
        }
        templateCode += code.slice(start);
        scriptCode += spaces.slice(start);
        this.sourceCode = {
            template: templateCode,
            scripts: new ScriptsSourceCode(scriptCode, scriptAttrs),
        };
        this.scriptLet = new script_let_1.ScriptLetContext(this);
    }
    getLocFromIndex(index) {
        let loc = this.locsMap.get(index);
        if (!loc) {
            loc = this.locs.getLocFromIndex(index);
            this.locsMap.set(index, loc);
        }
        return {
            line: loc.line,
            column: loc.column,
        };
    }
    /**
     * Get the location information of the given node.
     * @param node The node.
     */
    getConvertLocation(node) {
        const { start, end } = node;
        return {
            range: [start, end],
            loc: {
                start: this.getLocFromIndex(start),
                end: this.getLocFromIndex(end),
            },
        };
    }
    addComment(comment) {
        this.comments.push(comment);
    }
    /**
     * Add token to tokens
     */
    addToken(type, range) {
        const token = Object.assign({ type, value: this.getText(range) }, this.getConvertLocation(range));
        this.tokens.push(token);
        return token;
    }
    /**
     * get text
     */
    getText(range) {
        return this.code.slice(range.start, range.end);
    }
    isTypeScript() {
        var _a, _b;
        if (this.state.isTypeScript != null) {
            return this.state.isTypeScript;
        }
        const lang = this.sourceCode.scripts.attrs.lang;
        if (!lang) {
            return (this.state.isTypeScript = false);
        }
        const parserName = (0, resolve_parser_1.getParserName)(this.sourceCode.scripts.attrs, (_a = this.parserOptions) === null || _a === void 0 ? void 0 : _a.parser);
        if (parserName === "@typescript-eslint/parser") {
            return (this.state.isTypeScript = true);
        }
        if (parserName.includes("@typescript-eslint/parser")) {
            let targetPath = parserName;
            while (targetPath) {
                const pkgPath = path_1.default.join(targetPath, "package.json");
                if (fs_1.default.existsSync(pkgPath)) {
                    try {
                        return (this.state.isTypeScript =
                            ((_b = JSON.parse(fs_1.default.readFileSync(pkgPath, "utf-8"))) === null || _b === void 0 ? void 0 : _b.name) === "@typescript-eslint/parser");
                    }
                    catch (_c) {
                        return (this.state.isTypeScript = false);
                    }
                }
                const parent = path_1.default.dirname(targetPath);
                if (targetPath === parent) {
                    break;
                }
                targetPath = parent;
            }
        }
        return (this.state.isTypeScript = false);
    }
    stripScriptCode(start, end) {
        this.sourceCode.scripts.stripCode(start, end);
    }
    findBlock(element) {
        const tag = element.type === "SvelteScriptElement" ? "script" : "style";
        return this.blocks.find((block) => block.tag === tag &&
            element.range[0] <= block.contentRange[0] &&
            block.contentRange[1] <= element.range[1]);
    }
}
exports.Context = Context;
/** Extract <script> blocks */
function* extractBlocks(code) {
    const startTagOpenRe = /<(script|style)([\s>])/giu;
    const endScriptTagRe = /<\/script>/giu;
    const endStyleTagRe = /<\/style>/giu;
    let startTagOpenMatch;
    while ((startTagOpenMatch = startTagOpenRe.exec(code))) {
        const [, tag, nextChar] = startTagOpenMatch;
        let startTagEnd = startTagOpenRe.lastIndex;
        let attrs = [];
        if (!nextChar.trim()) {
            const attrsData = (0, html_1.parseAttributes)(code, startTagOpenRe.lastIndex);
            attrs = attrsData.attributes;
            startTagEnd = attrsData.index;
            if (code[startTagEnd] === "/") {
                startTagEnd++;
            }
            if (code[startTagEnd] === ">") {
                startTagEnd++;
            }
            else {
                continue;
            }
        }
        const endTagRe = tag.toLowerCase() === "script" ? endScriptTagRe : endStyleTagRe;
        endTagRe.lastIndex = startTagEnd;
        const endTagMatch = endTagRe.exec(code);
        if (endTagMatch) {
            const endTagStart = endTagMatch.index;
            const contentRange = [startTagEnd, endTagStart];
            yield {
                contentRange,
                attrs,
                tag: tag,
            };
            startTagOpenRe.lastIndex = endTagRe.lastIndex;
        }
    }
}
class LinesAndColumns {
    constructor(code) {
        const len = code.length;
        const lineStartIndices = [0];
        for (let index = 0; index < len; index++) {
            const c = code[index];
            if (c === "\r") {
                const next = code[index + 1] || "";
                if (next === "\n") {
                    index++;
                }
                lineStartIndices.push(index + 1);
            }
            else if (c === "\n") {
                lineStartIndices.push(index + 1);
            }
        }
        this.lineStartIndices = lineStartIndices;
    }
    getLocFromIndex(index) {
        const lineNumber = sortedLastIndex(this.lineStartIndices, index);
        return {
            line: lineNumber,
            column: index - this.lineStartIndices[lineNumber - 1],
        };
    }
    getIndexFromLoc(loc) {
        const lineStartIndex = this.lineStartIndices[loc.line - 1];
        const positionIndex = lineStartIndex + loc.column;
        return positionIndex;
    }
}
exports.LinesAndColumns = LinesAndColumns;
/**
 * Uses a binary search to determine the highest index at which value should be inserted into array in order to maintain its sort order.
 */
function sortedLastIndex(array, value) {
    let lower = 0;
    let upper = array.length;
    while (lower < upper) {
        const mid = Math.floor(lower + (upper - lower) / 2);
        const target = array[mid];
        if (target < value) {
            lower = mid + 1;
        }
        else if (target > value) {
            upper = mid;
        }
        else {
            return mid + 1;
        }
    }
    return upper;
}
